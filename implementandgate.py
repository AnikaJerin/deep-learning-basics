# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V-qE-V3IMHzzMWpBxwRnb-cgCWrGl9sX
"""



#impelement and and or gate
#for and gate any of the input is low the output is low and both input has to be high for the hight output
import tensorflow.compat.v1 as tf
tf.disable_v2_behavior()

T,F=1.,-1.

bias=1.
#bias will always be 1
#training out data
train_in=[
       [T,T,bias], #when both of the inputs are true
       [T,F,bias],
       [F,T,bias],
       [F,F,bias],
] #input
train_out=[
           [T],
           [F],
           [F],
           [F],
]
#tensorflow works by building a model out of empty tensors then plugging in knowing values and evaluating the model
#training data we've provided will remain constant the only tensorflow object we have to worry about is 3X1 tensors in vectors
#define a variable and put a random value in it
w=tf.Variable(tf.random_normal([3,1])) #values will change in each evaluation we perform

#define a activation function
def step(x):
  is_greater=tf.greater(x,0)
  as_float=tf.to_float(is_greater)
  doubled=tf.multiply(as_float,2)
  return tf.subtract(doubled,1)
#the output error and men square error can be calculated
output=step(tf.matmul(train_in,w))
error=tf.subtract(train_out,output)
#meansq err
mse=tf.reduce_mean(tf.square(error))
#evaluation of certain tensor functions can also update the values of variables like w
#1st we need to calculate the desired adjustment based on error then we add it to w
delta=tf.matmul(train_in,error,transpose_a=True)
train=tf.assign(w,tf.add(w,delta))
sess=tf.compat.v1.Session()
sess.run(tf.initialize_all_variables())
# performing iterations so we get 0 error
#define var err and target
err,target= 1, 0 #our target is making the error 0
#define epoch. epoch is nothing but a no. of cycles or no. of iterations that will be required to reach the desired output or in order to reduce the error to0
epoch,max_epoch=0,10 #that means it will start from 0 epoch and max val'll be 10
while err>target and epoch<max_epoch:
  epoch+=1
  err,_=sess.run([mse,train])
  print('epoch:',epoch, 'mse',err) #the cycle of epoch and the respective error of that perticular cycle